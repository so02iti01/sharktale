<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sharktale</title>
  
  
  <link href="http://blog.sharktale.xyz/atom.xml" rel="self"/>
  
  <link href="http://blog.sharktale.xyz/"/>
  <updated>2022-06-21T13:04:17.674Z</updated>
  <id>http://blog.sharktale.xyz/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Notes|docker 使用与排查笔记</title>
    <link href="http://blog.sharktale.xyz/docker-commands/"/>
    <id>http://blog.sharktale.xyz/docker-commands/</id>
    <published>2022-06-12T10:09:13.000Z</published>
    <updated>2022-06-21T13:04:17.674Z</updated>
    
    <content type="html"><![CDATA[<p>我会用到的关于 docker 和 docker compose 的简单笔记</p><span id="more"></span><h2 id="容器上线与删除"><a href="#容器上线与删除" class="headerlink" title="容器上线与删除"></a>容器上线与删除</h2><div class="story post-story"><pre><code class="shell">sudo nano docker-compose.yml      # 写 dockerfile    sudo rm docker-compose.yml        # 移除 dockerfiledocker-compose up -d              # 上线容器docker-compose down               # 删除容器</code></pre></div><h2 id="检查-docker-运行问题"><a href="#检查-docker-运行问题" class="headerlink" title="检查 docker 运行问题"></a>检查 docker 运行问题</h2><div class="story post-story"><p>针对容器</p><pre><code class="shell">docker container ls               # 显示 container ID, 创建时间, 运行状态, portsdocker ps                         # 显示所有 container 的信息</code></pre><blockquote><p>可以用这个命令，查看 container 是否在发生不断 restart 的故障</p></blockquote><pre><code class="shell">docker logs &lt;container_ID&gt;        # 显示某个 container 的运行日志</code></pre><blockquote><p>用来查看 container 发生故障的详细原因</p></blockquote><pre><code class="shell">docker stop &lt;container_ID&gt;       # 停止某个容器docker rm &lt;Container_ID&gt;         # 删除某个容器</code></pre><p>针对镜像</p><pre><code class="shell">docker images                     # 展示 IMAGE ID，IMAGE 的版本(时间)docker rmi &lt;IMAGE_ID&gt;             # 删除对应镜像rm -rf miniflux-db                # 删除持久化数据，使用volumes:下面的名字</code></pre></div><h2 id="容器内部执行命令"><a href="#容器内部执行命令" class="headerlink" title="容器内部执行命令"></a>容器内部执行命令</h2><div class="story post-story"><p>非 docker 安装时，可以切换到某个目录，再执行这个应用特有的命令。但是，使用 docker 安装的应用，执行特定操作时，则需要用到 <a href="https://docs.docker.com/engine/reference/commandline/exec/"><code>docker exec</code></a>命令</p><p>两种情况的情况的区别</p><pre><code class="shell"># Disabling serverside encryption)# (1)非 docker 安装的 Nextcloudcd /var/www/nextcloud.sudo -u www-data ./occ maintenance:singleuser –on   # Switch the Nextcloud single user mode to onsudo -u www-data ./occ encryption:disable. # Disable encryptionsudo -u www-data ./occ maintenance:singleuser –off  # Turn off single user mode with the command# (2)docker 安装的 Nextclouddocker exec -it -u www-data nextcloud_app_1 php occ # 查询 nextcloud 所有可用命令，这里的 nextcloud_app_1 是 Container_Namedocker exec -it -u www-data nextcloud_app_1 php occ encryption:decrypt-all # Disable server-side encryption and decrypt all files</code></pre><h3 id="输出容器内可执行命令列表"><a href="#输出容器内可执行命令列表" class="headerlink" title="输出容器内可执行命令列表"></a>输出容器内可执行命令列表</h3><p>安装 <a href="https://github.com/lavie/runlike">runlike</a></p><pre><code class="shell">apt install python3-pippip install runlike</code></pre><p>输出命令</p><pre><code class="shell">runlike &lt;container_ID&gt;</code></pre><h3 id="docker-exec-的用法"><a href="#docker-exec-的用法" class="headerlink" title="docker exec  的用法"></a>docker exec  的用法</h3><pre><code class="shell">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code></pre><blockquote><p>options：</p><table><thead><tr><th>Name, shorthand</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>--detach</code> , <code>-d</code></td><td></td><td>Detached mode: run command in the background</td></tr><tr><td><code>--detach-keys</code></td><td></td><td>Override the key sequence for detaching a container</td></tr><tr><td><code>--env</code> , <code>-e</code></td><td></td><td>Set environment variables</td></tr><tr><td><code>--env-file</code></td><td></td><td>Read in a file of environment variables</td></tr><tr><td><code>--interactive</code> , <code>-i</code></td><td></td><td>Keep STDIN open even if not attached</td></tr><tr><td><code>--privileged</code></td><td></td><td>Give extended privileges to the command</td></tr><tr><td><code>--tty</code> , <code>-t</code></td><td></td><td>Allocate a pseudo-TTY</td></tr><tr><td><code>--user</code> , <code>-u</code></td><td></td><td>Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</td></tr><tr><td><code>--workdir</code> , <code>-w</code></td><td></td><td>Working directory inside the container</td></tr></tbody></table></blockquote><p>examples：</p><pre><code class="shell"># (1)create a container named ubuntu_bash and start a Bash session.docker run --name ubuntu_bash --rm -i -t ubuntu bash# (2)create a new file /tmp/execWorks inside the running container ubuntu_bash, in the background.docker exec -d ubuntu_bash touch /tmp/execWorks# (3)create a new Bash session in the container ubuntu_bash.docker exec -it ubuntu_bash bash# (4)create a new Bash session in the container ubuntu_bash with environment variable $VAR set to “1”.docker exec -it -e VAR=1 ubuntu_bash bash     # Note that this environment variable will only be valid on the current Bash session. By default docker exec command runs in the same working directory set when container was created.</code></pre></div><h2 id="切换位置"><a href="#切换位置" class="headerlink" title="切换位置"></a>切换位置</h2><div class="story post-story"><p>切换到容器数据所在位置</p><pre><code class="shell">docker container exec -it &lt;container_ID&gt; bash</code></pre><p>之后就可以正常使用 <code>cd</code></p></div><h2 id="从容器内部复制文件夹到容器外面"><a href="#从容器内部复制文件夹到容器外面" class="headerlink" title="从容器内部复制文件夹到容器外面"></a>从容器内部复制文件夹到容器外面</h2><div class="story post-story"><pre><code class="shell">docker cp &lt;container_ID&gt;:/file/path/within/container /host/path/target</code></pre></div><h2 id="identify-which-container-owns-which-overlay-directory"><a href="#identify-which-container-owns-which-overlay-directory" class="headerlink" title="identify which container owns which overlay directory"></a>identify which container owns which overlay directory</h2><div class="story post-story"><p><code>overlay</code> 位于 <code>/var/lib/docker/overlay</code>，用于存放 container 的数据文件</p><p>一个讲容器和目录对应起来的运行命令</p><pre><code>docker inspect $(docker ps -qa) |  jq -r &#39;map([.Name, .GraphDriver.Data.MergedDir]) | .[] | &quot;\(.[0])\t\(.[1])&quot;&#39;</code></pre><p>输出子文件夹名称和对应的 contianer name</p><blockquote><p>部分命令说明：</p><pre><code>docker inspect $(docker ps -qa)   # Display full docker details.jq -r   # Parse json and output regular stringsmap([.Name, .GraphDriver.Data.MergedDir])   # For each element in the original array, find the `Name` and the overlay `MergedDir`.&quot;\(.[0])\t\(.[1])&quot;  # Output the first two elements of the array.</code></pre></blockquote></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;我会用到的关于 docker 和 docker compose 的简单笔记&lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="http://blog.sharktale.xyz/tags/docker/"/>
    
    <category term="docker-compose" scheme="http://blog.sharktale.xyz/tags/docker-compose/"/>
    
    <category term="Nextcloud" scheme="http://blog.sharktale.xyz/tags/Nextcloud/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB|从 IEEE Xplore 批量下载论文</title>
    <link href="http://blog.sharktale.xyz/bulk-download-from-IEEE-Xplore/"/>
    <id>http://blog.sharktale.xyz/bulk-download-from-IEEE-Xplore/</id>
    <published>2022-05-24T06:55:39.000Z</published>
    <updated>2022-06-21T13:04:17.674Z</updated>
    
    <content type="html"><![CDATA[<p>手动从 IEEE Xplore 导出 .csv，主要使用 MATLAB 的函数 <code>webread</code> 和 <code>websave</code> 实现自动批量下载。</p><span id="more"></span><p>参考了<a href="https://zouyuze.blogspot.com/2017/10/download-ieee-xplore-pdfs-in-batch.html">这篇</a>，修改了自定义函数的部分文字输出，写了些注释和使用说明</p><p>使用要求：</p><ul><li>连接校园网</li><li>自己的校园网可以下载  IEEE Xplore</li><li>有 MATLAB</li></ul><p>选好文献，导出 <code>.csv 文件</code>之后，填写 <code>.csv 文件</code>的位置</p><pre><code class="matlab">clcexport = &#39;C:\Users\xxxx\Downloads\export2022.05.24-01.31.59.csv&#39;; % .csv地址skip = 0;DownloadPDFfromXplore(export, skip); % pdf会下载到current folder</code></pre><p>其中，自定义函数 <code>DownloadPDFfromXplore</code> 内容</p><pre><code class="matlab">function DownloadPDFfromXplore(export, skip)%% download pdf from IEEE EXplore export file% if termites at any exception, we can restart and skip those downloaded if nargin == 1    skip = 0;end[raw_numerical, raw_text, ~] = xlsread(export); % 读取.csv文件信息UrlList = raw_text(skip+3:end, 16);NameList = raw_text(skip+3:end, 1);YearList = raw_numerical(skip+1:end, 1);pat = &#39;[\\/:*?&quot;&lt;&gt;|]&#39;; NameList = regexprep(NameList, pat, &#39; &#39;); % 替换文件名中不允许出现的符号为空格for k = 1 : length(NameList)   html = webread(UrlList&#123;k&#125;);   first = strfind(html, &#39;&lt;iframe src=&quot;h&#39;);   last = strfind(html, &#39;&quot; frameborder=0&gt;&#39;);   url = html(first+13:last-1);   filename = [num2str(YearList(k)) &#39; &#39; NameList&#123;k&#125; &#39;.pdf&#39;];   websave(filename, url); % 将url地址内容保存到本地并命名为filename。   myString  = fprintf(&#39;(%d/%d) %s ... DONE\n&#39;,k,length(NameList),filename);   disp(myString);  % 显示获取进度   waitTime = 30 * rand() + 30;  % 模拟人工操作的随机等待时间，避免被封IP   pause(waitTime);end</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;手动从 IEEE Xplore 导出 .csv，主要使用 MATLAB 的函数 &lt;code&gt;webread&lt;/code&gt; 和 &lt;code&gt;websave&lt;/code&gt; 实现自动批量下载。&lt;/p&gt;</summary>
    
    
    
    
    <category term="download" scheme="http://blog.sharktale.xyz/tags/download/"/>
    
    <category term="IEEE" scheme="http://blog.sharktale.xyz/tags/IEEE/"/>
    
    <category term="MATLAB" scheme="http://blog.sharktale.xyz/tags/MATLAB/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu|新 linux 主机需要的一些设置</title>
    <link href="http://blog.sharktale.xyz/what_is_required_for_a_new_host/"/>
    <id>http://blog.sharktale.xyz/what_is_required_for_a_new_host/</id>
    <published>2022-05-18T05:06:39.000Z</published>
    <updated>2022-06-21T13:04:17.674Z</updated>
    
    <content type="html"><![CDATA[<p>updated （2022-05-18）: 根据 <a href="https://seviche.cc/">酸橘汁腌鱼</a> 的 <a href="https://seviche.cc/2022-05-07-vps-init">VPS 安全初始化 </a> 进行了修改</p><span id="more"></span><h2 id="设置与连接-SSH"><a href="#设置与连接-SSH" class="headerlink" title="设置与连接 SSH"></a>设置与连接 SSH</h2><div class="story post-story"><h3 id="安装-PuTTY"><a href="#安装-PuTTY" class="headerlink" title="安装 PuTTY"></a>安装 PuTTY</h3><p>使用 windows 电脑连接 remote 的 Linux VPS，需要一个图形化的界面</p><blockquote><p> If your Windows is Windows 10 Version 1803, OpenSSH Client has been implemented as a Windows feature, so it’s possible to use ssh command on command prompt without Putty and other SSH software.</p></blockquote><p>open SSH 客户端的使用大同小异。下载 <a href="https://www.putty.org/">PuTTY</a>，本次需要用到的是 <code>PuTTY</code> 和 <code>PuTTYgen</code>，这两个在一次安装后都会出现</p><h3 id="进行-SSH-连接"><a href="#进行-SSH-连接" class="headerlink" title="进行 SSH 连接"></a>进行 SSH 连接</h3><p>打开 <code>PuTTY</code>，输入 Host Name ( IP address )，和 Port  (一般为22) ，然后按下 <code>open</code>，进入一个命令行窗口。在命令行窗口中，输入登录信息（login as 与 password，这两个在购买 VPS 的时候就已经得到了）</p><blockquote><p>密码在输入的过程中，是不显示的，如果输入正确，会显示一些 VPS 系统相关的简要信息</p></blockquote><h3 id="更新-VPS-的-packages"><a href="#更新-VPS-的-packages" class="headerlink" title="更新 VPS 的 packages"></a>更新 VPS 的 packages</h3><p>在上一步中如果密码输入正确，还会显示需要更新的内容。输入一下内容，进行可更新 packages 的检查</p><pre><code class="shell">apt update</code></pre><p>再次输入 apt update，即可开始更新，更新完成后需要 reboot，使更新生效</p><h3 id="创建新用户并修改用户权限"><a href="#创建新用户并修改用户权限" class="headerlink" title="创建新用户并修改用户权限"></a>创建新用户并修改用户权限</h3><p>前面都使用 root 账户操作，root 对系统具有全部权限，因而可能对系统造成严重的损害，所以使用 root 是 不够安全的。而一个具有 superuser 权限的常规账户，需要在命令前面加上 <code>sudo</code> 前缀，才能获取管理员权限。<br>添加新用户：</p><pre><code class="shell">adduser &lt;your new username&gt;</code></pre><p>为新用户增加 superuser 权限：</p><pre><code class="shell">usermod -aG sudo &lt;your new username&gt;</code></pre><h3 id="增加-public-key-认证"><a href="#增加-public-key-认证" class="headerlink" title="增加 public key 认证"></a>增加 public key 认证</h3><p>打开 <code>PuTTYgen</code>，点击 <code>generate</code> ，产生 public key。需要填写 <code>Key passphrase</code>，passphrase 会与产生的 key 一起作为密码</p><blockquote><p>keys 产生速度慢的原因找到了……是没有再产生时，在下方空白随意移动鼠标（提示文字说这样可以加入随意的部分在keys中）</p></blockquote><p>填写完成后，在页面选择 <code>Save private key</code>，把产生的文件保存在自己的电脑上。先不要关闭窗口，后面的操作还需要 <code>copy public key</code></p><p>按照前面2步的方法，使用原来的 <code>root</code> 账号登录VPS。</p><p>使用以下命令，可以移动到之前创建的新用户的 home directory，这样命令行会对应到创建的新用户</p><pre><code class="shell">su – &lt;your new username&gt;</code></pre><p>之后，按照顺序输入下面的命令，作用是：为 <code>public key</code> 创建新文件夹，限制获取这个文件夹的权限，并且保存 public key</p><pre><code class="shell">mkdir ~/.sshchmod 700 ~/.sshnano ~/.ssh/authorized_keys</code></pre><p>最后一个命令会开启 <code>Nano editor</code>。</p><p>从之前的 <code>PuTTYgen</code> 窗口复制 <code>public key</code>，并且粘贴在这里。</p><blockquote><p>一定要是直接从 Puttygen 复制，才符合authorized_keys的格式要求，后面才不会连接不上！如果发生了这样的事故，请在VPS运行商的页面上选择 Access &gt; Reset root password</p></blockquote><p>然后按住 <code>CTRL + X</code>，来关闭 <code>Nano editor</code>。系统会询问是否保存对 <code>authorized_keys</code> 文件的更改，输入 <code>Y</code>，确认更改</p><p>输入下面的命令，作用：更改刚才编辑的文件的 permissions，并返回到  <code>root</code>  用户</p><pre><code class="shell">chmod 600 ~/.ssh/authorized_keysexit</code></pre><p>打开 <code>PuTTY</code>，选择菜单 <code>Connection › SSH › Auth</code>，Browser 载入 private keys</p><p>通过SSH连接VPS，并且按照前面的方法，以新用户的身份登入</p><p>输入下面的命令来关闭默认的密码的认证方式</p><blockquote><p>注意：如果前面没有用keys登录成功，就不要开始关闭密码认证方式。如果前面设置错了，直接去服务商的网站上去 Rebuild &gt; re-install，然后 Access &gt;Reset root password，然后一切重头再来……</p></blockquote><pre><code class="shell">sudo nano /etc/ssh/sshd_config</code></pre><p>修改下面的内容（这里参考了鱼的文章）</p><pre><code>PermitRootLogin no    AllowUsers username   #如果没有这一行就手动添加RSAAuthentication yes #这一行我找不到就没有配置PubkeyAuthentication yesPasswordAuthentication no # 禁止使用密码登录</code></pre><p>修改完成后，和前面一样，按住 <code>CTRL + X</code>，来关闭 <code>Nano editor</code>，输入 <code>Y</code>，确认更改</p><p><code>Reboot VPS</code> 或者 输入 </p><pre><code class="shell">service sshd restart</code></pre><p>下次登录的时候，就需要使用 <code>private key</code> 和 <code>passphrase</code> 了</p><h3 id="改-SSH-端口"><a href="#改-SSH-端口" class="headerlink" title="改 SSH 端口"></a>改 SSH 端口</h3><p>这部分是新增的，参考了鱼的文章</p><p>还是在 <code>/etc/ssh/sshd_config</code>中，在 <code>Port 22</code> 下面增加一行</p><pre><code>Port &lt;你选择的端口号&gt;     # 换一个22以外的端口号</code></pre><p>重启 sshd</p><pre><code class="shell">sudo service sshd restart</code></pre><p>打开防火墙，为新增的端口放行。设置好之后，用新端口重新连接一下，没问题的话，注释掉 <code>Port 22</code> </p></div><h2 id="为-VPS-安装防火墙"><a href="#为-VPS-安装防火墙" class="headerlink" title="为 VPS 安装防火墙"></a>为 VPS 安装防火墙</h2><div class="story post-story"><p>设置防火墙之后，可以限制 VPS 向网络开放的端口。这样可以阻止很多针对服务器的攻击。可以使用 <a href="https://en.wikipedia.org/wiki/Iptables">iptables</a> ，来设置一个防火墙。</p><blockquote><p>iptables 只适用于 <code>ipv4</code> 协议，如果需要适用 <code>ipv6</code>协议，需要转而使用<code>ip6tables</code></p></blockquote><p><code>ufw</code> 也是一个常用的 firewall，也可以使用 <code>ufw</code> （<code>ufw</code> 的设置说不定还要更简单</p><h3 id="什么是-iptables"><a href="#什么是-iptables" class="headerlink" title="什么是 iptables"></a>什么是 iptables</h3><p>iptables 是 Linux 的一种防火墙程序，它使用 tables 监控来自和去往你的服务器的流量。这些 tables 包含一系列的 rules (<code>chains</code>), 可以过滤包含数据的 packets。</p><p>[optin-monster-shortcode id&#x3D;”fv4lqeko3gylvecpszws”]</p><p>每当一个 <code>packet</code> 符合一个 <code>rule</code>, 会被添加一个 target。 target 可以是另一个 <code>rule</code> 或者下列特殊值之一：</p><ul><li><code>ACCEPT</code> – 允许通过</li><li><code>DROP</code> – 丢弃（不能通过）</li><li><code>RETURN</code> – 不能通过这一次的 rule，转送到上一次的 rule</li></ul><p>默认的 tables (<code>filter</code>)包含下面3个 rules：</p><ul><li><p><code>INPUT</code> – 过滤进入 server 的 packet</p></li><li><p><code>FORWARD</code> – 过滤将要被 server 转发 (forward) 的 packet</p></li><li><p><code>OUTPUT</code> – 过滤离开 server 的 packet</p></li></ul><h3 id="安装并使用-Iptables"><a href="#安装并使用-Iptables" class="headerlink" title="安装并使用 Iptables"></a>安装并使用 Iptables</h3><h4 id="安装-Iptables"><a href="#安装-Iptables" class="headerlink" title="安装 Iptables"></a>安装 Iptables</h4><pre><code class="shell">sudo apt-get updatesudo apt-get install iptables</code></pre><p>检查现有 Iptables 设置：</p><pre><code class="shell">sudo iptables -L -v</code></pre><p>-L：列出所有的rules， -v：展示详细信息</p><p>显示所有的 chains 都设置为了 <code>ACCEPT</code>，也即是没有 rules（所有的 packet 都能通过）。</p><h4 id="定义新-chain-rules"><a href="#定义新-chain-rules" class="headerlink" title="定义新 chain rules"></a>定义新 chain rules</h4><p>新定义的 rule 需要被挂在 chain 的后面，所以需要在 iptables 命令后面加上 <code>-A</code> 选项 (<code>Append</code>)，同时与下面的选项结合：</p><ul><li><code>-i (interface)</code> — the network interface whose traffic you want to filter, such as eth0, lo, ppp0, etc.</li><li><code>-p (protocol)</code> — the network protocol where your filtering process takes place. It can be either <code>tcp</code>, <code>udp</code>, <code>udplite</code>, <code>icmp</code>, <code>sctp</code>, <code>icmpv6</code>, and so on. Alternatively, you can type <code>all</code> to choose every protocol.</li><li><code>-s (source</code>) — the address from which traffic comes from. You can add a hostname or IP address.</li><li><code>–dport (destination port)</code> — the destination port number of a protocol, such as <code>22 (SSH)</code>, <code>443 (https)</code>, etc.</li><li><code>-j (target)</code> — the target name (<code>ACCEPT</code>, <code>DROP</code>, <code>RETURN</code>). You need to insert this every time you make a new rule.</li></ul><pre><code class="shell">sudo iptables -A &lt;chain&gt; -i &lt;interface&gt; -p &lt;protocol (tcp/udp) &gt; -s &lt;source&gt; --dport &lt;port no.&gt;  -j &lt;target&gt;</code></pre><p>在下面用 <code>INPUT</code> chain 作为示例。</p><h5 id="允许主机内通信"><a href="#允许主机内通信" class="headerlink" title="允许主机内通信"></a>允许主机内通信</h5><p>使用 lo (loopback) 接口：</p><pre><code class="shell">sudo iptables -A INPUT -i lo -j ACCEPT</code></pre><p>这个命令让同一台机器上的数据库和应用程序正常通信</p><h5 id="开启-HTTP-SSH-和-SSL-端口"><a href="#开启-HTTP-SSH-和-SSL-端口" class="headerlink" title="开启 HTTP, SSH 和 SSL 端口"></a>开启 HTTP, SSH 和 SSL 端口</h5><p>协议和端口号的对应是：<code>http</code> (port <code>80</code>), <code>https</code> (port <code>443</code>), 和 <code>ssh</code> (port <code>22</code>) 。这里需要指定 <code>-p</code> 和 <code>–dport</code> 参数。 </p><pre><code class="shell">sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPTsudo iptables -A INPUT -p tcp --dport 80 -j ACCEPTsudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT</code></pre><p>检查是否添加进 rule：</p><pre><code class="shell">sudo iptables -L -v</code></pre><h5 id="基于-IP-地址过滤-packet"><a href="#基于-IP-地址过滤-packet" class="headerlink" title="基于 IP 地址过滤 packet"></a>基于 IP 地址过滤 packet</h5><p>用到 <code>-s</code> 选项，例如扔掉来自 192.168.1.3 的 packet：</p><pre><code class="shell">sudo iptables -A INPUT -s 192.168.1.3 -j DROP</code></pre><p>如果想要扔掉某个范围 IP地址的 packet，需要先加上 <code>-m  iprange</code>，然后用 <code>––src-range</code> 加上 IP 地址的范围，例如：</p><pre><code class="shell">sudo iptables -A INPUT -m iprange --src-range 192.168.1.100-192.168.1.200 -j DROP</code></pre><h5 id="扔掉不符合端口号的所有packets"><a href="#扔掉不符合端口号的所有packets" class="headerlink" title="扔掉不符合端口号的所有packets"></a>扔掉不符合端口号的所有packets</h5><p>需要先用上面的方法，设置允许的端口号。</p><pre><code class="shell">sudo iptables -A INPUT -j DROP</code></pre><h5 id="删除-rules"><a href="#删除-rules" class="headerlink" title="删除 rules"></a>删除 rules</h5><p><strong>删除所有的rules</strong>：<code>-F</code> 选项 (<code>flush</code>):</p><pre><code class="shell">sudo iptables -F</code></pre><p><strong>删除某一条rule</strong>： <code>-D</code> 选项：</p><p>先排序查看 rules</p><pre><code class="shell">sudo iptables -L --line-numbers</code></pre><p>会出现类似下面的情况</p><pre><code class="bash">Chain INPUT (policy ACCEPT)num  target     prot opt source               destination1    ACCEPT     all -- 192.168.0.4          anywhere2    ACCEPT     tcp -- anywhere             anywhere tcp dpt:https3    ACCEPT     tcp -- anywhere             anywhere tcp dpt:http4    ACCEPT     tcp -- anywhere             anywhere tcp dpt:ssh</code></pre><p>需要用到 chain 类型和序号来执行删除命令。例如，删除 <code>INPUT</code> chain 的第 3 条：</p><pre><code class="shell">sudo iptables -D INPUT 3</code></pre><h4 id="关闭-Iptables-防火墙"><a href="#关闭-Iptables-防火墙" class="headerlink" title="关闭 Iptables 防火墙"></a>关闭 Iptables 防火墙</h4><pre><code class="shell">sudo iptables -Fsudo /sbin/iptables-save</code></pre><h4 id="保存-Iptables-更改"><a href="#保存-Iptables-更改" class="headerlink" title="保存 Iptables 更改"></a>保存 Iptables 更改</h4><p>Iptables chains 更改的数据存于缓存里，但是重启 server 之后需要重新定义 chains。采用下面的命令，保证重启后更改仍是生效的。</p><blockquote><p>每次更改 Iptables 后，都应该运行这个命令</p></blockquote><pre><code class="shell">sudo /sbin/iptables-save</code></pre></div><h2 id="进一步的安全防护"><a href="#进一步的安全防护" class="headerlink" title="进一步的安全防护"></a>进一步的安全防护</h2><div class="story post-story"><p>这里参考 <a href="https://seviche.cc/">酸橘汁腌鱼</a> 的 <a href="https://seviche.cc/2022-05-07-vps-init">VPS 安全初始化 </a> ，感谢鱼的文章，让我知道了更多 VPS 的安全防护方法</p><h3 id="运行防病毒软件-ClamAV"><a href="#运行防病毒软件-ClamAV" class="headerlink" title="运行防病毒软件 ClamAV"></a>运行防病毒软件 ClamAV</h3><pre><code class="shell"># 安装sudo apt updatesudo apt install clamav clamav-daemon -ysudo systemctl stop clamav-freshclam # 停止服务sudo freshclam # 执行更新sudo systemctl start clamav-freshclam # 再次启动 clamav-freshclamsudo systemctl is-enabled clamav-freshclam # 设置开机自启动ls /var/lib/clamav/ # 下载 ClamAV 数据库# nice：降低 clamscan 的优先级（限制相对 cpu 时间）sudo nice -n 15 clamscan # 限制 Clamscan CPU 使用率# cpulimit：限制绝对的 CPU 时间。 安装cpulimitsudo apt-get install cpulimitcpulimit -z -e clamscan -l 20 &amp; clamscan -ir /</code></pre><p>其它可能用到的命令</p><pre><code class="shell">clamscan /home/filename.docx  #扫描特定目录或文件clamscan --no-summary /home/ #扫描结束时不显示摘要clamscan -i / #打印受感染的文件clamscan --bell -i /home #警惕病毒检测clamscan -r --remove /home/USER #删除受感染的文件</code></pre><p>返回码</p><ul><li>0：未发现病毒。</li><li>1：发现病毒。</li><li>2：发生了一些错误。</li></ul><h3 id="安装-fail2ban-以阻止重复登录尝试"><a href="#安装-fail2ban-以阻止重复登录尝试" class="headerlink" title="安装 fail2ban 以阻止重复登录尝试"></a>安装 fail2ban 以阻止重复登录尝试</h3><pre><code class="shell">sudo apt update sudo apt upgrade -ysudo apt install fail2bansudo nano /etc/fail2ban/jail.local</code></pre><p>写入</p><pre><code class="shell">[DEFAULT]destemail = your@email.heresendername = Fail2Ban[sshd]enabled = trueport = 22   # 换成前面自己设置的 SSH 端口号[sshd-ddos]enabled = trueport = 22  # 换成前面自己设置的 SSH 端口号</code></pre><p>重启fail2ban</p><pre><code class="shell">sudo systemctl restart fail2ban</code></pre></div><h2 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h2><div class="story post-story"><p>鱼的新文章还给出了安全检查的 tips，看一看会更有收获：</p><p><a href="https://seviche.cc/2022-05-07-vps-init#%E6%97%A5%E5%B8%B8%E9%98%B2%E6%8A%A4">https://seviche.cc/2022-05-07-vps-init#%E6%97%A5%E5%B8%B8%E9%98%B2%E6%8A%A4</a></p></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><div class="story post-story"><p>[1] <a href="https://www.hostinger.com/tutorials/getting-started-with-vps-hosting">5 Steps to Get Your New Virtual Private Server (VPS) Ready to Use</a></p><p>[2] <a href="https://www.hostinger.com/tutorials/iptables-tutorial">Iptables Tutorial – Securing Ubuntu VPS with Linux Firewall</a></p><p>[3] <a href="https://seviche.cc/">酸橘汁腌鱼</a> 的 <a href="https://seviche.cc/2022-05-07-vps-init">VPS 安全初始化 </a> </p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;updated （2022-05-18）: 根据 &lt;a href=&quot;https://seviche.cc/&quot;&gt;酸橘汁腌鱼&lt;/a&gt; 的 &lt;a href=&quot;https://seviche.cc/2022-05-07-vps-init&quot;&gt;VPS 安全初始化 &lt;/a&gt; 进行了修改&lt;/p&gt;</summary>
    
    
    
    
    <category term="VPS" scheme="http://blog.sharktale.xyz/tags/VPS/"/>
    
    <category term="PuTTY" scheme="http://blog.sharktale.xyz/tags/PuTTY/"/>
    
    <category term="Iptables" scheme="http://blog.sharktale.xyz/tags/Iptables/"/>
    
  </entry>
  
</feed>
